### Vue.nextTick()
> 官方解释：在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即调用这个方法，获取更新后的DOM。

也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？

考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。

**什么时候需要用Vue.nextTick()**

1. 在Vue生命周期created()钩子函数进行的DOM操作一定要放在 Vue.nextTick() 的回调函数中，因为在 created() 钩子函数执行的时候 DOM 其实还并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted() 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和渲染都已完成，此时在该钩子函数进行任何的 DOM 操作都不会有问题。
2. 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该被放进 Vue.nextTick() 回调函数中。


### Vue中的生命周期
- beforeCreate 在实例初始化，数据观测(data observer)和event/watcher时间配置之前被调用
- created 实例已经被创建完成之后被调用。在这一步，实例已完成以下配置：数据观测(data observer)，属性和方法的运算，watch/event时间回调。然而，挂载阶段还没开始，$el属性目前不可见
- beforeMount 在挂载开始之前被调用，相关的render函数首次被调用
- mounted el被新创建的vm $el替换，并挂载到实例上去之后调用该钩子
- beforeUpdate 数据更新时调用，发生虚拟DOM重新渲染和打补丁之前。你可以在这个钩子进一步更改状态，这不会触发附加的重渲染过程。
- updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用钩子。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作，然而大多数情况下，你应该避免在此期间更改状态，因为可能会导致更新无限循环。该钩子在服务端期间不被调用。
- beforeDestroy 实例销毁之前调用，在这一步，实例仍然完全可用
- destroyed vue实例销毁后调用，调用后，vue实例指示的所有东西都会被解绑，所有的事件监听会被移除，所有的子实例也会被销毁，该钩子在服务端渲染期间不被调用。