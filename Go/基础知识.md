### 文件名、关键字和标识符

_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。

### 包的概念、导入与可见性

如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。另外要注意的是，所有的包名都应该使用小写字母。

属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。

**如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译**

如果包名不是以 . 或 / 开头，如 "fmt" 或者 "container/list"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。

### 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。比如fmt.Print()。

### 变量

```go
var a int
var b bool
var str string

var (
  a int
  b bool
  str string
)
```
这种因式分解关键字的写法一般用于声明全局变量。
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

**当你在函数体内声明局部变量时，应使用简短声明语法 :=**

全局变量允许声明但不使用，但局部变量声明后不使用会编译错误。

### 结构体

```go
type identifier struct {
  field1 type1
  field2 type2
  ...
}
```
**使用new**
使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)，如果需要可以把这条语句放在不同的行（比如定义是包范围的，但是分配却没有必要在开始就做）。

```go
var t * T
t = new(T)
```

写这条语句的惯用方法是：t := new(T)，变量 t 是一个指向 T的指针，此时结构体字段的值是它们所属类型的零值。

声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型T。**在这两种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（Object）**

```go
type myStruct struct { i int }
var v myStruct    // v是结构体类型变量
var p *myStruct   // p是指向一个结构体类型变量的指针
v.i
p.i

// 初始化一个结构体实例(一个结构体字面量：struct-literal)的更简短和惯用的方式如下：
ms := &struct1{10, 15.5, "Chris"}
// 此时ms的类型是 *struct1

或者：
var mt struct1
ms := struct1{10, 15.5, "Chris"}
```

混合字面量语法（composite literal syntax）`&struct1{a, b, c}` 是一种简写，底层仍然会调用 new ()，**这里值的顺序必须按照字段顺序来写**。在下面的例子中能看到可以通过在值的前面放上字段名来初始化字段的方式。表达式 new(Type)和 &Type{} 是等价的。

```go
type Interval struct {
  start int
  end   int
}

// 初始化方式
intr := Interval{0, 3}            (A) // 值必须以字段在结构体定义时的顺序给出，& 不是必须的
intr := Interval{end:5, start:1}  (B) // 字段名加一个冒号放在值的前面，这种情况下值的顺序不必一致
intr := Interval{end:5}           (C) // 某些字段还可以被忽略掉
```