### 文件名、关键字和标识符

_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。

**rune是int32的别称，byte是uint8的别称。**

**break 可⽤于 for、switch、select，而 continue 仅能⽤于 for 循环。**

```go
switch x {
case 10:
  println("a")
  fallthrough // 如需要继续下一分⽀支，可使⽤用 fallthrough，但不再判断条件。
case 0:
  println("b")
}

输出：
a
b
```

变参实质上就是slice，智能有一个，且必须是最后一个。使用slice对象做变参时，必须展开
```go
func test (n ...int) r int {
  var r int
  for _, i := range n {
    r += i
  }
  return // 命名返回参数可看做与形参类似的局部变量，最后由return隐式返回
  // return r
}

func main () {
  s := []int{1, 2, 3}
  sum(s...)
}
```

### GO环境配置

### 包的概念、导入与可见性

如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。另外要注意的是，所有的包名都应该使用小写字母。

属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。

**如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译**

如果包名不是以 . 或 / 开头，如 "fmt" 或者 "container/list"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。

### 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。比如fmt.Print()。

1. 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
2. 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。

**方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型**

因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：

func (a *denseMatrix) Add(b Matrix) Matrix
func (a *sparseMatrix) Add(b Matrix) Matrix

> 面向对象之结构体方法
`func (r ReceiverType) funcName(parameters) (results)`

```go
package main
import (
  "fmt"
  "math"
)

type Rectangle struct {
  width, height float64
}

type Circle struct {
  radius float64
}

func (r Rectangle) area() float64 {
  return r.width*r.height
}

func (c Circle) area() float64 {
  return c.radius * c.radius * math.Pi
}

func main() {
  r1 := Rectangle{12, 2}
  r2 := Rectangle{9, 4}
  c1 := Circle{10}
  c2 := Circle{25}

  fmt.Println("Area of r1 is: ", r1.area())
  fmt.Println("Area of r2 is: ", r2.area())
  fmt.Println("Area of c1 is: ", c1.area())
  fmt.Println("Area of c2 is: ", c2.area())
}
```

```go
// 结构体类型上的方法
type TwoInts struct {
  a int
  b int
}

func main() {
  two1 := new(TwoInts)
  two1.a = 12
  two1.b = 10

  fmt.Printf("The sum is: %d\n", two1.AddThem())
  fmt.Printf("Add them to the param: %d\n", two1.AddToParam(20))

  two2 := TwoInts{3, 4}
  fmt.Printf("The sum is: %d\n", two2.AddThem())
}

func (tn *TwoInts) AddThem() int {
  return tn.a + tn.b
}

func (tn *TwoInts) AddToParam(param int) int {
  return tn.a + tn.b + param
}

// 非结构体类型上方法的例子
type IntVector []int

func (v IntVector) Sum() (s int) {
  for _, x := range v {
    s += x
  }
  return
}

func main() {
  fmt.Println(IntVector{1, 2, 3}.Sum()) // 输出是6
}

// 错误
func (t time.Time) first3Chars() string {
  return time.LocalTime().String()[0:3]
}
类型在其他的，或是非本地的包里定义，在它上面定义方法都会得到和上面同样的错误。
但是有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型，然后再为别名类型定义方法。或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。
```

**函数将变量作为参数：Function1(recv)**
**方法在变量上被调用：recv.Method1()**

### 变量

```go
var a int
var b bool
var str string

var (
  a int
  b bool
  str string
)
```
这种因式分解关键字的写法一般用于声明全局变量。
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

**当你在函数体内声明局部变量时，应使用简短声明语法 :=**

全局变量允许声明但不使用，但局部变量声明后不使用会编译错误。

### 常量
> 常量的初始化规则与枚举

- 在定义常量时，如果不提供初始值，则表示使用上行的表达式
- 使用相同的表达式不代表具有相同的值
- iota是常量的计时器，从0开始，组中每定义1个常量自动递增1
- 通过初始化规则与iota可以达到枚举的效果
- 每遇到一个const关键字，iota就会重置为0

```go
const (
  // a与b都为"A"
  a = "A"
  b
  c = iota
  d // d的值为3
)

const (
  e = iota
  f // f的值为1
)

```

### 字符串
在Go中字符串是不可变的，例如下面的代码编译时会报错：`cannot assign to s[0]`

```go
var s string = "hello"
s[0] = 'c'

但如果真的想要修改怎么办呢？下面的代码可以实现：
s := "hello"
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf("%s\n", s2)

修改字符串也可写为：
s := "hello"
s = "c" + s[1:] // 字符串虽不能更改，但可进行切片操作
fmt.Printf("%s\n", s)
```

**要修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组**

Go里面有一个关键字`iota`，这个关键字用来声明`enum`的时候采用，它默认开始值是0，每调用一次加1：

```go
const(
  x = iota  // x == 0
  y = iota  // y == 1
  z = iota  // z == 2
  w  // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用"= iota"
)

const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0

const ( 
  e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同
)
```
### 数组
在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。
`arr := [...]int{1, 2, 3}`
### 引用类型
内置函数 new 计算类型⼤⼩，为其分配零值内存，返回指针。⽽ make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象⽽而⾮非指针。

### 切片
一个slice类型一般写作[]T，其中T代表slice中元素的类型。
`make`用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new`用于各种类型的内存分配。
`make`只能创建`slice`、`map`和`channel`

`slice := make([]string)`

### Map映射
禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。

### 结构体
注意`slice`和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用`...`自动计算长度，而声明`slice`时，方括号内没有任何字符。

**如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。**
使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)

```go
package main

type Foo map[string]string
type Bar struct {
  thingOne string
  thingTwo int
}

func main() {
  // OK
  y := new(Bar)
  (*y).thingOne = "hello"
  (*y).thingTwo = 1

  // NOT OK
  z := make(Bar) // 编译错误：cannot make type Bar
  (*z).thingOne = "hello"
  (*z).thingTwo = 1

  // OK
  x := make(Foo)
  x["x"] = "goodbye"
  x["y"] = "world"

  // NOT OK
  u := new(Foo)
  (*u)["x"] = "goodbye" // 运行时错误!! panic: assignment to entry in nil map
  (*u)["y"] = "world"
}
```
**试图 make() 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 new() 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 new(Foo) 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎。**

```go
type identifier struct {
  field1 type1
  field2 type2
  ...
}
```
**使用new**
使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)，如果需要可以把这条语句放在不同的行（比如定义是包范围的，但是分配却没有必要在开始就做）。

```go
var t * T
t = new(T)
```

写这条语句的惯用方法是：t := new(T)，**变量 t 是一个指向 T的指针**，此时结构体字段的值是它们所属类型的零值。

声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型T。**在这两种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（Object）**

```go
type myStruct struct { i int }
var v myStruct    // v是结构体类型变量
var p *myStruct   // p是指向一个结构体类型变量的指针
v.i
p.i

// 初始化一个结构体实例(一个结构体字面量：struct-literal)的更简短和惯用的方式如下：
ms := &struct1{10, 15.5, "Chris"}
// 此时ms的类型是 *struct1

或者：
var mt struct1
mt := struct1{10, 15.5, "Chris"}
```

混合字面量语法（composite literal syntax）`&struct1{a, b, c}` 是一种简写，底层仍然会调用 new ()，**这里值的顺序必须按照字段顺序来写**。在下面的例子中能看到可以通过在值的前面放上字段名来初始化字段的方式。表达式 new(Type)和 &Type{} 是等价的。

```go
type Interval struct {
  start int
  end   int
}

// 初始化方式
intr := Interval{0, 3}            (A) // 值必须以字段在结构体定义时的顺序给出，& 不是必须的
intr := Interval{end:5, start:1}  (B) // 字段名加一个冒号放在值的前面，这种情况下值的顺序不必一致
intr := Interval{end:5}           (C) // 某些字段还可以被忽略掉
```

> struct的匿名字段
结构体中只提供类型，而不写字段的方式，也就是匿名字段，也就是嵌入字段。
当匿名字段是一个struct的时候，那么这个struct所拥有的字段都被隐式地引入了当前定义的这个struct。

```go
type Human struct {
  name string
  age int
  weight int
}

type Student struct {
  Human // 匿名字段，那么Student就包含了Human的所有字段 感觉有点像继承
  speciality string
}

func main() {
  mark := Student{Human{"Mark", 25, 130}, "Computer Science"}
}
```

### 指针

变量是一种使用方便的占位符，用于引用计算机内存地址。
Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。
一个指针变量指向了一个值的内存地址。

在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。

传值与传指针
当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。

为了验证我们上面的说法，我们来看一个例子：

```go
package main
import "fmt"

//简单的一个函数，实现了参数+1的操作
func add1(a int) int {
  a = a + 1 // 我们改变了a的值
  return a //返回一个新值
}

func main() {
  x := 3
  fmt.Println("x = ", x)  // 应该输出 "x = 3"
  x1 := add1(x)  //调用add1(x)
  fmt.Println("x+1 = ", x1) // 应该输出"x+1 = 4"
  fmt.Println("x = ", x)    // 应该输出"x = 3"
}
```
看到了吗？虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化
理由很简单：因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。
那你也许会问了，如果真的需要传这个x本身,该怎么办呢？

这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子

```go
package main
import "fmt"

//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
  *a = *a + 1 // 修改了a的值
  return *a // 返回新值
}

func main() {
  x := 3
  fmt.Println("x = ", x)  // 应该输出 "x = 3"
  x1 := add1(&x)  // 调用 add1(&x) 传x的地址
  fmt.Println("x+1 = ", x1) // 应该输出 "x+1 = 4"
  fmt.Println("x = ", x)    // 应该输出 "x = 4"
}
```

这样，我们就达到了修改x的目的。那么到底传指针有什么好处呢？

- 传指针使得多个函数能操作同一个对象。
- 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。
- Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）

### 优雅的defer
Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照`逆序`执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：
```go
func ReadWrite() bool {
  file.Open("file")
  // 做一些工作
  if failureX {
    file.Close()
    return false
  }
  if failureY {
    file.Close()
    return false
  }
  file.Close()
  return true
}
```
在defer后指定的函数会在函数退出前调用。
```go
func ReadWrite() bool {
  file.Open("file")
  defer file.Close()
  if failureX {
    return false
  }
  if failureY {
    return false
  }
  return true
}
```
### interface

**一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口**
```go
type NokiaPhone struct {}

type Phone interface {
  call()
}


func (nokiaPhone NokiaPhone) call() {
  fmt.Println("I am Nokia, I can call you!")
}

func main () {
  var phone Phone

  phone = new(NokiaPhone)
  phone.call()
}
```

```go
type People struct {
	name string
	age int
}

type Men interface {
	sayHi()
}

func (p *People) sayHi() {
	fmt.Println(p.name)
}

func main() {
	man := People{"tom", 18}
	man.sayHi()
}
```

fmt.Printf它会把结果写到标准输出和fmt.Sprintf它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。

```go
func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)
func Printf(format string, args ...interface{}) (int, error) {
  return Fprintf(os.Stdout, format, args...)
}
func Sprintf(format string, args ...interface{}) string {
  var buf bytes.Buffer
  Fprintf(&buf, format, args...) // 传递指针，而不用在函数内容返回该值，在下一行直接被修改过的buf
  return buf.String()
}
```

### Channels

1. 带有缓存的channels
Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，一个发送操作——或许是整个程序——可能会永远阻塞。如果你只是需要一个简单的队列，使用slice就可以了。

如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。

```go
func mirroredQuery() string {
  responses := make(chan string, 3)
  go func() { responses <- request("asia.gopl.io") }()
  go func() { responses <- request("europe.gopl.io") }()
  go func() { responses <- request("americas.gopl.io") }()
  return <-responses // return the quickest response
}

func request(hostname string) (response string) { }

它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。

如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。
```

2. 不带缓存的channels
一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。

基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。

- 串联的Channels
- 单方向的Channels

### 锁
**不要使用共享数据来通信；使用通信来共享数据**
