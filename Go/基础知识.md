### 文件名、关键字和标识符

_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。

rune是int32的别称，byte是uint8的别称。

### 包的概念、导入与可见性

如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。另外要注意的是，所有的包名都应该使用小写字母。

属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。

**如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译**

如果包名不是以 . 或 / 开头，如 "fmt" 或者 "container/list"，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。

### 函数

只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。比如fmt.Print()。

> 面向对象之结构体方法
`func (r ReceiverType) funcName(parameters) (results)`

```go
package main
import (
  "fmt"
  "math"
)

type Rectangle struct {
  width, height float64
}

type Circle struct {
  radius float64
}

func (r Rectangle) area() float64 {
  return r.width*r.height
}

func (c Circle) area() float64 {
  return c.radius * c.radius * math.Pi
}

func main() {
  r1 := Rectangle{12, 2}
  r2 := Rectangle{9, 4}
  c1 := Circle{10}
  c2 := Circle{25}

  fmt.Println("Area of r1 is: ", r1.area())
  fmt.Println("Area of r2 is: ", r2.area())
  fmt.Println("Area of c1 is: ", c1.area())
  fmt.Println("Area of c2 is: ", c2.area())
}
```

### 变量

```go
var a int
var b bool
var str string

var (
  a int
  b bool
  str string
)
```
这种因式分解关键字的写法一般用于声明全局变量。
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

**当你在函数体内声明局部变量时，应使用简短声明语法 :=**

全局变量允许声明但不使用，但局部变量声明后不使用会编译错误。

### 字符串
在Go中字符串是不可变的，例如下面的代码编译时会报错：`cannot assign to s[0]`

```go
var s string = "hello"
s[0] = 'c'

但如果真的想要修改怎么办呢？下面的代码可以实现：
s := "hello"
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf("%s\n", s2)

修改字符串也可写为：
s := "hello"
s = "c" + s[1:] // 字符串虽不能更改，但可进行切片操作
fmt.Printf("%s\n", s)
```

Go里面有一个关键字`iota`，这个关键字用来声明`enum`的时候采用，它默认开始值是0，每调用一次加1：

```go
const(
  x = iota  // x == 0
  y = iota  // y == 1
  z = iota  // z == 2
  w  // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用"= iota"
)

const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0

const ( 
  e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同
)
```

### 切片
`make`用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new`用于各种类型的内存分配。
`make`只能创建`slice`、`map`和`channel`

### 结构体
注意`slice`和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用`...`自动计算长度，而声明`slice`时，方括号内没有任何字符。

```go
type identifier struct {
  field1 type1
  field2 type2
  ...
}
```
**使用new**
使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)，如果需要可以把这条语句放在不同的行（比如定义是包范围的，但是分配却没有必要在开始就做）。

```go
var t * T
t = new(T)
```

写这条语句的惯用方法是：t := new(T)，变量 t 是一个指向 T的指针，此时结构体字段的值是它们所属类型的零值。

声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型T。**在这两种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（Object）**

```go
type myStruct struct { i int }
var v myStruct    // v是结构体类型变量
var p *myStruct   // p是指向一个结构体类型变量的指针
v.i
p.i

// 初始化一个结构体实例(一个结构体字面量：struct-literal)的更简短和惯用的方式如下：
ms := &struct1{10, 15.5, "Chris"}
// 此时ms的类型是 *struct1

或者：
var mt struct1
mt := struct1{10, 15.5, "Chris"}
```

混合字面量语法（composite literal syntax）`&struct1{a, b, c}` 是一种简写，底层仍然会调用 new ()，**这里值的顺序必须按照字段顺序来写**。在下面的例子中能看到可以通过在值的前面放上字段名来初始化字段的方式。表达式 new(Type)和 &Type{} 是等价的。

```go
type Interval struct {
  start int
  end   int
}

// 初始化方式
intr := Interval{0, 3}            (A) // 值必须以字段在结构体定义时的顺序给出，& 不是必须的
intr := Interval{end:5, start:1}  (B) // 字段名加一个冒号放在值的前面，这种情况下值的顺序不必一致
intr := Interval{end:5}           (C) // 某些字段还可以被忽略掉
```

> struct的匿名字段
结构体中只提供类型，而不写字段的方式，也就是匿名字段，也就是嵌入字段。
当匿名字段是一个struct的时候，那么这个struct所拥有的字段都被隐式地引入了当前定义的这个struct。

```go
type Human struct {
  name string
  age int
  weight int
}

type Student struct {
  Human // 匿名字段，那么Student就包含了Human的所有字段 感觉有点像继承
  speciality string
}

func main() {
  mark := Student{Human{"Mark", 25, 130}, "Computer Science"}
}
```

### 指针

变量是一种使用方便的占位符，用于引用计算机内存地址。
Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。
一个指针变量指向了一个值的内存地址。

在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。

传值与传指针
当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。

为了验证我们上面的说法，我们来看一个例子：

```go
package main
import "fmt"

//简单的一个函数，实现了参数+1的操作
func add1(a int) int {
  a = a + 1 // 我们改变了a的值
  return a //返回一个新值
}

func main() {
  x := 3
  fmt.Println("x = ", x)  // 应该输出 "x = 3"
  x1 := add1(x)  //调用add1(x)
  fmt.Println("x+1 = ", x1) // 应该输出"x+1 = 4"
  fmt.Println("x = ", x)    // 应该输出"x = 3"
}
```
看到了吗？虽然我们调用了add1函数，并且在add1中执行a = a+1操作，但是上面例子中x变量的值没有发生变化
理由很简单：因为当我们调用add1的时候，add1接收的参数其实是x的copy，而不是x本身。
那你也许会问了，如果真的需要传这个x本身,该怎么办呢？

这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子

```go
package main
import "fmt"

//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
  *a = *a + 1 // 修改了a的值
  return *a // 返回新值
}

func main() {
  x := 3
  fmt.Println("x = ", x)  // 应该输出 "x = 3"
  x1 := add1(&x)  // 调用 add1(&x) 传x的地址
  fmt.Println("x+1 = ", x1) // 应该输出 "x+1 = 4"
  fmt.Println("x = ", x)    // 应该输出 "x = 4"
}
```

这样，我们就达到了修改x的目的。那么到底传指针有什么好处呢？

- 传指针使得多个函数能操作同一个对象。
- 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。
- Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）

### 优雅的defer
Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照`逆序`执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：
```go
func ReadWrite() bool {
  file.Open("file")
  // 做一些工作
  if failureX {
    file.Close()
    return false
  }
  if failureY {
    file.Close()
    return false
  }
  file.Close()
  return true
}
```
在defer后指定的函数会在函数退出前调用。
```go
func ReadWrite() bool {
  file.Open("file")
  defer file.Close()
  if failureX {
    return false
  }
  if failureY {
    return false
  }
  return true
}
```
### interface

```go
type NokiaPhone struct {}

type Phone interface {
  call()
}


func (nokiaPhone NokiaPhone) call() {
  fmt.Println("I am Nokia, I can call you!")
}

func main () {
  var phone Phone

  phone = new(NokiaPhone)
  phone.call()
}
```

```go
type People struct {
	name string
	age int
}

type Men interface {
	sayHi()
}

func (p *People) sayHi() {
	fmt.Println(p.name)
}

func main() {
	man := People{"tom", 18}
	man.sayHi()
}
```