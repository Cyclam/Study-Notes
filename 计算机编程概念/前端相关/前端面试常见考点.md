
### 难点
1. 双向绑定和响应式原理
2. http缓存相关知识
3. 前端安全
4. 渐进增强和优雅降级
5. 闭包（闭包只能取得包含函数中任何变量的最后一个值，解释for循环最后取值）
6. ES6
7. 盒子模型
8. Cookie、SessionStorage、LocalStorage的区别
9. 前端优化手段（async和defer的区别）
- defer 和 async 在网络读取（下载）这块儿是一样的，都是**异步**的（相较于 HTML 解析）
- 它俩的差别**在于脚本下载完之后何时执行**，显然 defer 是最接近我们对于应用脚本加载和执行的要求的
- 关于 defer，此图未尽之处在于它是**按照加载顺序执行脚本**的，这一点要善加利用
- async 则是一个**乱序执行**的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行
- 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics
10. 如何创建一个BFC（1. 浮动 2. inline-block、table-cell布局 3. 绝对定位；作用是可以包含浮动元素，不被浮动元素覆盖，阻止父子元素margin覆盖）

### 前端SEO

1. 合理的title、desecription、keywords
2. html标签语义化
3. 少用iframe
4. 提高网站速度
5. 非装饰性图片必须加alt属性

### 前端性能优化方法

1. 合并压缩js、css、html文件
2. 压缩图片，小于2k的图片可以考虑base64，将不常更改的多个小图片合为一张图片，也就是css sprite。
3. 后端服务器开启Gzip压缩，减小字节传输大小
4. 使用外部引入的css、js文件，css文件放在head中(FOUC：解决页面在加载样式之前使用默认样式从而导致页面闪烁问题)，js文件放在body闭合标签之前
5. 使用多个域名下的静态资源，因为浏览器对同一个域名下请求的资源有并行请求数量限制
6. 给多个js文件合理添加async、defer属性，从而不用使浏览器等待js文件下载（async和defer的区别）
7. 使用Web Worker 启用多线程处理（不能操作DOM、BOM）
8. DNS、CDN部署与缓存
9. 不滥用web字体
10. 避免内联样式
11. 减少不必要的重定向

### CSS部分

1. 盒子模型，IE盒子模型的content包含padding和border
2. 什么内容的修改会造成页面的重绘和回流
3. 清除浮动的方法（空元素、伪元素）
4. CSS样式优先级 !important > 行内样式 > 内部样式 > 外部样式

```css
.clear:before,
.clear:after {
    content: "";
    display: table;
}
.clear:after {
    clear: both;
}
.clear {
    *zoom: 1;
}
```
4. 居中实现方式

### JavaScript部分

1. sessionStorage、localStorage、Cookie的区别
- 都会在浏览器端保存，有大小限制，同源限制
- cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器
- cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie
- 有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除
- 共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享
- localStorage的修改会促发其他文档窗口的update事件
- cookie有secure属性要求HTTPS传输
- 浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M

2. 解决跨域的几种方式
- Get请求 使用jsonp
- 后端设置**Access-Control-Allow-Origin**跨域头部
- 使用postMessage方法
- 使用webSocket
- nginx反向代理

3. 六种基本数据类型 undefined、null、string、boolean、number、symbol

4. 继承的几种方式
```javascript
function Shape(){}
function Rect(){}

- Rect.prototype = new Shape(); // 原型链继承
- Rect.prototype = Shape.prototype;
- Rect.prototype = Object.create(Shape.prototype); // ES5中的继承
- 使用call或apply，在子类构造函数中调用父类的构造函数
```

### Event Loop

1. 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

### JSON 实现深拷贝

`JSON.stringify(JSON.parse(obj))`

### 防抖、节流

### 原生 Ajax 请求
见 XMLHttpRequest.js